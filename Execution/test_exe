import sys,  time, os, json
from datetime import datetime
import subprocess
from pprint import PrettyPrinter 
def PP (stuff , pp = PrettyPrinter(indent=4)) :
    return pp.pprint(stuff)

from Executeur import Executeur

path = "../outils"
if path not in sys.path : 
    sys.path.append (path)
    
from Gestion_commandes import Gestion_commandes
from Gestion_reponses import  Gestion_reponses

from lire_dico_json import lire_dico_json




def clean () :
    def detruire (pathFile,) :
        if os.path.exists(pathFile) :
            os.remove(pathFile)
            print ('fichier detruit en ', pathFile)
        else: 
            print ('n existe pas = ', pathFile)

    def verif_vide (pathFile) :
        try:
            f = open (pathFile, 'r')
            data = f.read ()
            resultat = json.loads (data)
            assert resultat == {} , "fichier " + pathFile + " non vide ?"
        except :
            assert False, "fichier " + pathFile + " n'existe pas ?"
        return


    # initialisation à zero des messages    
    nom_environnement = 'general'

    path = '../data/'+ nom_environnement + '/parametres/'
    pathReponses = path + 'dico_reponses.json'
    dico_reponses = lire_dico_json (pathReponses)

    pathFile = path + dico_reponses ['pathFile']
    pathFile_lock = pathFile + ".lock"

    detruire (pathFile_lock)
    detruire (pathFile,)



    pathCommandes = path + 'dico_commandes.json'
    dico_commandes = lire_dico_json (pathCommandes)
    pathFile = path + dico_commandes ['pathFile']
    pathFile_lock = pathFile + ".lock"
    detruire (pathFile_lock,)
    detruire (pathFile,)

    # test init on test en réel le demarrage avec mise à vide de la liste des messages

    E = Executeur()




    path = '../data/'+ nom_environnement + '/parametres/'
    pathReponses = path + 'dico_reponses.json'
    dico_reponses = lire_dico_json (pathReponses)

    pathFile = path + dico_reponses ['pathFile']
    verif_vide (pathFile)

    pathCommandes = path + 'dico_commandes.json'
    dico_commandes = lire_dico_json (pathCommandes)
    pathFile = path + dico_commandes ['pathFile']
    verif_vide (pathFile)

    return

import sys,  time, os, json
from datetime import datetime
import subprocess
from pprint import PrettyPrinter 
def PP (stuff , pp = PrettyPrinter(indent=4)) :
    return pp.pprint(stuff)

from Executeur import Executeur

path = "../outils"
if path not in sys.path : 
    sys.path.append (path)
    
from Gestion_commandes import Gestion_commandes
from Gestion_reponses import  Gestion_reponses

from lire_dico_json import lire_dico_json



def lancement_executeur () :
    bashCommand = "python lancement_executeur.py"
    process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
    """
    output, error = process.communicate()
    if not error is None :
        raise ValueError
    """
    return process

def arret_executeur (process) :
    process.terminate ()
    return

clean ()
G = Gestion_commandes ()
R = Gestion_reponses ()

date = datetime.now()
date_voulu = date. strftime('%y/%m/%d %H:%M:%S.%f')
assert isinstance(date_voulu, type(' '))

message = {'nb_max_worker' : 1, 'nb_max_erreur' : 1, 'date_voulu' : date_voulu, 'nom_appel' : 'test1',
       'parametres' : {'arg' : {'test' : 'hello world nouveau'}, 'nom_appel' : 'test1'}}


#dico, numero_commande = G.put_new_message (message)
#dico, resultat = R.get_dico_reponses_done ()
#resultat
    



